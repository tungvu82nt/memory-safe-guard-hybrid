/**\n * useLoadingState Hook\n * Tách riêng loading state management để tái sử dụng\n * \n * Features:\n * - Centralized loading state\n * - Error handling\n * - Operation wrapper\n */\n\nimport { useState, useCallback } from 'react';\n\ninterface LoadingStateConfig {\n  showToast?: boolean;\n  successMessage?: string;\n}\n\ninterface UseLoadingStateReturn {\n  loading: boolean;\n  error: string | null;\n  executeOperation: <T>(\n    operation: () => Promise<T>,\n    config?: LoadingStateConfig\n  ) => Promise<T | null>;\n  setError: (error: string | null) => void;\n  clearError: () => void;\n}\n\n/**\n * Custom hook để quản lý loading state và error handling\n * Refactor: Tách từ usePasswords để tái sử dụng\n */\nexport const useLoadingState = (): UseLoadingStateReturn => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const executeOperation = useCallback(async <T>(\n    operation: () => Promise<T>,\n    config: LoadingStateConfig = {}\n  ): Promise<T | null> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await operation();\n      \n      // TODO: Implement toast notifications based on config\n      if (config.showToast && config.successMessage) {\n        console.log('Success:', config.successMessage);\n      }\n      \n      return result;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Có lỗi xảy ra';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    loading,\n    error,\n    executeOperation,\n    setError,\n    clearError,\n  };\n};"